From deb9018638389b88e3d87b565180e103ba31a800 Mon Sep 17 00:00:00 2001
From: [REDACTED] <[redacted]@[redacted]>
Date: Tue, 27 Aug 2019 00:08:45 +0200
Subject: [PATCH] Added support for OpenSSL >= 1.1.0. Lots of structure types
 were hidden and became opaque pointers.

---
 srtp/CryptoContext.h            |  4 +++
 srtp/crypto/openssl/hmac.cpp    | 43 ++++++++++++++++++++++++------
 zrtp/crypto/openssl/hmac256.cpp | 18 +++++++++++++
 zrtp/crypto/openssl/hmac384.cpp | 22 +++++++++++++--
 zrtp/crypto/openssl/zrtpDH.cpp  | 47 +++++++++++++++++++++++++++++++--
 5 files changed, 122 insertions(+), 12 deletions(-)

diff --git a/srtp/CryptoContext.h b/srtp/CryptoContext.h
index 7962af1..10fe2ea 100644
--- a/srtp/CryptoContext.h
+++ b/srtp/CryptoContext.h
@@ -421,7 +421,11 @@ private:
     typedef union _hmacCtx {
         SkeinCtx_t       hmacSkeinCtx;
 #ifdef ZRTP_OPENSSL
+	#if OPENSSL_VERSION_NUMBER < 0x10100000L
         HMAC_CTX         hmacSha1Ctx;
+	#else
+		HMAC_CTX *		hmacSha1Ctx;
+	#endif
 #else
         hmacSha1Context  hmacSha1Ctx;
 #endif
diff --git a/srtp/crypto/openssl/hmac.cpp b/srtp/crypto/openssl/hmac.cpp
index 93a6d0d..f0f22fe 100644
--- a/srtp/crypto/openssl/hmac.cpp
+++ b/srtp/crypto/openssl/hmac.cpp
@@ -50,23 +50,42 @@ void hmac_sha1( uint8_t* key, int32_t key_length,
                 const uint8_t* data_chunks[],
                 uint32_t data_chunck_length[],
                 uint8_t* mac, int32_t* mac_length ) {
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
     HMAC_CTX ctx;
     HMAC_CTX_init(&ctx);
     HMAC_Init_ex(&ctx, key, key_length, EVP_sha1(), NULL);
+#else
+	HMAC_CTX* ctx;
+	ctx = HMAC_CTX_new();
+	HMAC_Init_ex(ctx, key, key_length, EVP_sha1(), NULL);
+#endif
     while (*data_chunks) {
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
         HMAC_Update(&ctx, *data_chunks, *data_chunck_length);
+#else
+		HMAC_Update(ctx, *data_chunks, *data_chunck_length);
+#endif
         data_chunks ++;
         data_chunck_length ++;
     }
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
     HMAC_Final(&ctx, mac, reinterpret_cast<uint32_t*>(mac_length));
     HMAC_CTX_cleanup(&ctx);
+#else
+	HMAC_Final(ctx, mac, reinterpret_cast<uint32_t*>(mac_length));
+	HMAC_CTX_free( ctx );
+#endif
 }
 
 void* createSha1HmacContext(uint8_t* key, int32_t key_length)
 {
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
     HMAC_CTX* ctx = (HMAC_CTX*)malloc(sizeof(HMAC_CTX));
 
     HMAC_CTX_init(ctx);
+#else
+	HMAC_CTX* ctx = HMAC_CTX_new();
+#endif
     HMAC_Init_ex(ctx, key, key_length, EVP_sha1(), NULL);
     return ctx;
 }
@@ -75,7 +94,11 @@ void* initializeSha1HmacContext(void* ctx, uint8_t* key, int32_t keyLength)
 {
     HMAC_CTX *pctx = (HMAC_CTX*)ctx;
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
     HMAC_CTX_init(pctx);
+#else
+	HMAC_CTX_reset(pctx);
+#endif
     HMAC_Init_ex(pctx, key, keyLength, EVP_sha1(), NULL);
     return pctx;
 }
@@ -85,9 +108,9 @@ void hmacSha1Ctx(void* ctx, const uint8_t* data, uint32_t data_length,
 {
     HMAC_CTX* pctx = (HMAC_CTX*)ctx;
 
-    HMAC_Init_ex(pctx, NULL, 0, NULL, NULL );
-    HMAC_Update(pctx, data, data_length );
-    HMAC_Final(pctx, mac, reinterpret_cast<uint32_t*>(mac_length) );
+    HMAC_Init_ex( pctx, NULL, 0, NULL, NULL );
+    HMAC_Update( pctx, data, data_length );
+    HMAC_Final( pctx, mac, reinterpret_cast<uint32_t*>(mac_length) );
 }
 
 void hmacSha1Ctx(void* ctx, const uint8_t* data[], uint32_t data_length[],
@@ -95,19 +118,23 @@ void hmacSha1Ctx(void* ctx, const uint8_t* data[], uint32_t data_length[],
 {
     HMAC_CTX* pctx = (HMAC_CTX*)ctx;
 
-    HMAC_Init_ex(pctx, NULL, 0, NULL, NULL );
+    HMAC_Init_ex( pctx, NULL, 0, NULL, NULL );
     while (*data) {
-        HMAC_Update(pctx, *data, *data_length);
+        HMAC_Update( pctx, *data, *data_length );
         data++;
         data_length++;
     }
-    HMAC_Final(pctx, mac, reinterpret_cast<uint32_t*>(mac_length) );
+    HMAC_Final( pctx, mac, reinterpret_cast<uint32_t*>(mac_length) );
 }
 
 void freeSha1HmacContext(void* ctx)
 {
     if (ctx) {
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
         HMAC_CTX_cleanup((HMAC_CTX*)ctx);
-        free(ctx);
+		free(ctx);
+#else
+		HMAC_CTX_free((HMAC_CTX*)ctx);
+#endif
     }
-}
\ No newline at end of file
+}
diff --git a/zrtp/crypto/openssl/hmac256.cpp b/zrtp/crypto/openssl/hmac256.cpp
index 40e4e82..6f5cf0e 100644
--- a/zrtp/crypto/openssl/hmac256.cpp
+++ b/zrtp/crypto/openssl/hmac256.cpp
@@ -53,15 +53,33 @@ void hmac_sha256(uint8_t* key, uint32_t key_length,
                  uint8_t* mac, uint32_t* mac_length )
 {
     unsigned int tmp;
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
     HMAC_CTX ctx;
     HMAC_CTX_init( &ctx );
     HMAC_Init_ex( &ctx, key, key_length, EVP_sha256(), NULL );
+#else
+	HMAC_CTX * ctx;
+	ctx = HMAC_CTX_new();
+	HMAC_Init_ex( ctx, key, key_length, EVP_sha256(), NULL );
+#endif
     while( *data_chunks ){
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
       HMAC_Update( &ctx, *data_chunks, *data_chunck_length );
+#else
+	  HMAC_Update( ctx, *data_chunks, *data_chunck_length );
+#endif
       data_chunks ++;
       data_chunck_length ++;
     }
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
     HMAC_Final( &ctx, mac, &tmp);
+#else
+	HMAC_Final( ctx, mac, &tmp);
+#endif
     *mac_length = tmp;
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
     HMAC_CTX_cleanup( &ctx );
+#else
+	HMAC_CTX_free( ctx );
+#endif
 }
diff --git a/zrtp/crypto/openssl/hmac384.cpp b/zrtp/crypto/openssl/hmac384.cpp
index 2511ce5..7445f25 100644
--- a/zrtp/crypto/openssl/hmac384.cpp
+++ b/zrtp/crypto/openssl/hmac384.cpp
@@ -51,15 +51,33 @@ void hmac_sha384(uint8_t* key, uint32_t key_length,
                  uint8_t* mac, uint32_t* mac_length )
 {
     unsigned int tmp;
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
     HMAC_CTX ctx;
-    HMAC_CTX_init( &ctx );
-    HMAC_Init_ex( &ctx, key, key_length, EVP_sha384(), NULL );
+	HMAC_CTX_init( &ctx );
+	HMAC_Init_ex( &ctx, key, key_length, EVP_sha384(), NULL );
+#else
+	HMAC_CTX * ctx;
+	ctx = HMAC_CTX_new();
+	HMAC_Init_ex( ctx, key, key_length, EVP_sha384(), NULL );
+#endif
     while( *data_chunks ){
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
       HMAC_Update( &ctx, *data_chunks, *data_chunck_length );
+#else
+      HMAC_Update( ctx, *data_chunks, *data_chunck_length );
+#endif
       data_chunks ++;
       data_chunck_length ++;
     }
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
     HMAC_Final( &ctx, mac, &tmp);
+#else
+	HMAC_Final( ctx, mac, &tmp);
+#endif
     *mac_length = tmp;
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
     HMAC_CTX_cleanup( &ctx );
+#else
+	HMAC_CTX_free( ctx );
+#endif
 }
diff --git a/zrtp/crypto/openssl/zrtpDH.cpp b/zrtp/crypto/openssl/zrtpDH.cpp
index 78cf60a..0c6e298 100644
--- a/zrtp/crypto/openssl/zrtpDH.cpp
+++ b/zrtp/crypto/openssl/zrtpDH.cpp
@@ -223,18 +223,41 @@ ZrtpDH::ZrtpDH(const char* type) {
     case DH3K:
         ctx = static_cast<void*>(DH_new());
         tmpCtx = static_cast<DH*>(ctx);
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
         tmpCtx->g = BN_new();
         BN_set_word(tmpCtx->g, DH_GENERATOR_2);
+#else
+		{
+		BIGNUM* g = BN_new();
+		BN_set_word(g, DH_GENERATOR_2);
+#endif
 
         if (pkType == DH2K) {
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
             tmpCtx->p = BN_dup(bnP2048);
+#else
+			DH_set0_pqg(tmpCtx, BN_dup(bnP2048), NULL, g);
+#endif
             RAND_bytes(random, 32);
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
             tmpCtx->priv_key = BN_bin2bn(random, 32, NULL);
+#else
+			DH_set0_key(tmpCtx, NULL, BN_bin2bn(random, 32, NULL));
+#endif
         }
         else if (pkType == DH3K) {
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
             tmpCtx->p = BN_dup(bnP3072);
+#else
+			DH_set0_pqg(tmpCtx, BN_dup(bnP3072), NULL, g);
+#endif
             RAND_bytes(random, 64);
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
             tmpCtx->priv_key = BN_bin2bn(random, 32, NULL);
+#else
+			DH_set0_key(tmpCtx, NULL, BN_bin2bn(random, 32, NULL));
+		}
+#endif
         }
         break;
 
@@ -269,11 +292,18 @@ int32_t ZrtpDH::computeSecretKey(uint8_t *pubKeyBytes, uint8_t *secret) {
     if (pkType == DH2K || pkType == DH3K) {
         DH* tmpCtx = static_cast<DH*>(ctx);
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
         if (tmpCtx->pub_key != NULL) {
             BN_free(tmpCtx->pub_key);
         }
         tmpCtx->pub_key = BN_bin2bn(pubKeyBytes, getDhSize(), NULL);
         return DH_compute_key(secret, tmpCtx->pub_key, tmpCtx);
+#else
+		DH_set0_key(tmpCtx, BN_bin2bn(pubKeyBytes, getDhSize(), NULL), NULL);
+		BIGNUM* pub_key;
+		DH_get0_key(tmpCtx, const_cast<const BIGNUM**>(&pub_key), NULL);
+		return DH_compute_key(secret, pub_key, tmpCtx);
+#endif
     }
     if (pkType == EC25 || pkType == EC38) {
         uint8_t buffer[200];
@@ -321,8 +351,15 @@ int32_t ZrtpDH::getDhSize() const
 
 int32_t ZrtpDH::getPubKeySize() const
 {
-    if (pkType == DH2K || pkType == DH3K)
-        return BN_num_bytes(static_cast<DH*>(ctx)->pub_key);
+	if (pkType == DH2K || pkType == DH3K) {
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
+		return BN_num_bytes(static_cast<DH*>(ctx)->pub_key);
+#else
+		BIGNUM* pub_key;
+		DH_get0_key(static_cast<DH*>(ctx), const_cast<const BIGNUM**>(&pub_key), NULL);
+		return BN_num_bytes(pub_key);
+#endif
+	}
 
     if (pkType == EC25 || pkType == EC38)
         return EC_POINT_point2oct(EC_KEY_get0_group(static_cast<EC_KEY*>(ctx)),
@@ -341,7 +378,13 @@ int32_t ZrtpDH::getPubKeyBytes(uint8_t *buf) const
         if (prepend > 0) {
             memset(buf, 0, prepend);
         }
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
         return BN_bn2bin(static_cast<DH*>(ctx)->pub_key, buf + prepend);
+#else
+		BIGNUM* pub_key;
+		DH_get0_key(static_cast<DH*>(ctx), const_cast<const BIGNUM**>(&pub_key), NULL);
+		return BN_bn2bin(pub_key, buf + prepend);
+#endif
     }
     if (pkType == EC25 || pkType == EC38) {
         uint8_t buffer[200];
-- 
2.20.1 ([Redacted] Git-117)

